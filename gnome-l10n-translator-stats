#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>

# Author  : Simos Xenitellis <simos@gnome.org>, 2009
# Version : 0.9

import dircache                 # dircache.listdir()
import os                       # os.system(), os.remove(), os.path.gmtime(), os.getenv()
import getopt                   # getopt.getopt()
import shutil                   # shutil.rmtree(), shutil.copyfile()
import sys                      # sys.argv, sys.exit()
import urllib                   # urllib.urlretrieve()
import ConfigParser             # ConfigParser()
import TextColorPrint
import GetKey                   # for GetKey.getch()
import re                       # for re.match()
import git                      # for git functionality
import time                     # time.mktime()
import subprocess               # for popen()
from datetime import datetime   # datetime()
import random                   # for random.random()
import filecmp                  # for filecmp.cmp()
import hashlib                  # for md5

import GNOMEI18nTarget

try:
    from lxml import etree      # etree.XMLParser(), etree.XML()
except ImportError as err:
    print 'Import error:', err
    print 'This script requires to have the "python-lxml" package installed'
    print 'Please install the package python-lxml and try again.\nExiting...'
    sys.exit(-10)

PROGNAME='gnome-l10n-translator-stats'

PACKAGE_NAME    = 'GNOME L10n Translator Stats'
PACKAGE_VERSION = '0.1'
PACKAGE_AUTHORS = ['Simos Xenitellis <simos@gnome.org>']
PACKAGE_COPYRIGHT = 'Copyright 2010 Simos Xenitellis'

class GNOMEL10nTranslatorStats:
    # Required configuration options
    language = ''
    release = ''

    # Options used for filtering
    category = ''
    module = ''
    transtype = ''              # either 'doc' or 'ui' (for 'document' or 'domain' in XML)

    common_short = 'dhv'
    common_long = ['dry-run', 'help', 'verbose']

    filter_short = 'c:m:r:t:'
    filter_long = ['category=', 'module=', 'release=', 'transtype=']

    # This is populated using lxml and the parsing of the l10n.gnome.org XML file.
    gnome_release_data = []

    # Hash table that contains the contributor effort
    # Key is git author name (such as 'Simos Xenitellis <simos@gnome.org>')
    # Value is number of translated words
    contributors = {}

    dir_vcs = ''
    file_START = 'START'

    file_CONFIG = ''

    # Text color object
    tc = ''

    action_stats = False
    action_cleanup = False

    opt_dryrun = False
    opt_gitverbose = False
    opt_gitquiet = False
    opt_verbose = False
    opt_cleanup = False

    def __init__(self, argv):
        # Initialise the text color object
        self.tc = TextColorPrint.TextColorPrint()

        # getkey object for kbhit()
        self.getkey = GetKey.GetKey()

        # If no args, show basic help.
        if not argv[1:]:
            self.usage(['intro', 'help'])
            sys.exit(0)

        # Identify the action selected.
        if argv[1] == 'stats':
                self.action_stats = True
        elif argv[1] == 'cleanup':
                self.action_cleanup = True
        else:
            self.usage(['intro', 'cleanup', 'stats',
                        'filtering', 'common'])
            sys.exit(0)

        # Perform the subsequence actions.
        if self.action_stats:
            self.process_stats(argv[2:])
        elif self.action_cleanup:
            self.process_cleanup(argv[2:])

        # Execution ends.
        print 'Action has just completed.'

    def highlight(self, str):
        ''' Returns a string with ANSI codes that print as color on the terminal window. '''
        return self.tc.cprint(str, 'red')

    def highlightitem(self, str):
        ''' Returns a string with ANSI codes that print as color on the terminal window. '''
        return self.tc.cprint(str, 'green')

    def highlightitem2(self, str):
        ''' Returns a string with ANSI codes that print as color on the terminal window. '''
        return self.tc.cprint(str, 'green_highlight')

    def highlighttitle(self, str):
        ''' Returns a string with ANSI codes that print as color on the terminal window. '''
        return self.tc.cprint(str, 'blue')

    def process_cleanup(self, cmdargs):
        if not cmdargs:
            self.usage(['intro', 'cleanup', 'filtering', 'common'])
            sys.exit(0)

        try:
                this_filter_short = self.common_short + self.filter_short
                this_filter_long = ['release=', 'git-verbose', 'repositories='];
                this_filter_long.extend(self.common_long)
                this_filter_long.extend(self.filter_long)
                opts, args = getopt.getopt(cmdargs, this_filter_short, this_filter_long)
        except getopt.GetoptError as err:
            print 'Error', err
            self.usage(['intro', 'cleanup', 'filtering', 'common'])
            sys.exit(0)
        for o, a in opts:
            if o in ('--dryrun', '--dry-run'):
                self.opt_dryrun = True
            if o in ('--release'):
                self.release = a
            if o in ('--repositories'):
                self.dir_vcs = a
            if o in ('--git-verbose'):
                self.opt_gitverbose = True
            if o in ('-h', '--help'):
                self.usage(['intro', 'cleanup', 'filtering', 'common'])
                sys.exit()
            if o in ('-v', '--verbose'):
                self.opt_verbose = True
            self.apply_filtering(o, a)

        # Language is not required for cleanup; we select one so that we can grab the XML package list
        self.language = 'el'
        self.parse_gnome_release_data()
        if self.release != 'master':
            CMD_REMOVE_STAT_BRANCHES = 'git checkout master ; git branch -D l10n-stats ; git branch -D ' + self.release + "; git reset --hard origin/master"
        else:
            CMD_REMOVE_STAT_BRANCHES = 'git checkout master ; git branch -D l10n-stats'
        self.perform_on_repositories(CMD_REMOVE_STAT_BRANCHES, 'Removing branches related to translation statistics')
        # CMD = 'git checkout master ; git branch -D l10n-stats ; git checkout gnome-2-26 ; git checkout -b l10n-stats'

    def process_stats(self, cmdargs):
        if not cmdargs:
            self.usage(['intro', 'stats', 'filtering', 'common'])
            sys.exit(0)

        try:
                this_filter_short = self.common_short + self.filter_short
                this_filter_long = ['language=', 'release=', 'git-verbose', 'startdate=', 'enddate=', 'repositories='];
                this_filter_long.extend(self.common_long)
                this_filter_long.extend(self.filter_long)
                opts, args = getopt.getopt(cmdargs, this_filter_short, this_filter_long)
        except getopt.GetoptError as err:
            print 'Error', err
            self.usage(['intro', 'stats', 'filtering', 'common'])
            sys.exit(0)
        for o, a in opts:
            if o in ('--dryrun', '--dry-run'):
                self.opt_dryrun = True
            if o in ('--language'):
                self.language = a
            if o in ('--release'):
                self.release = a
            if o in ('--repositories'):
                self.dir_vcs = a
            if o in ('--startdate'):
                temp_date = datetime(*time.strptime(a, "%Y/%m/%d")[0:5])
                self.startdate = time.mktime(temp_date.timetuple())
            if o in ('--enddate'):
                temp_date = datetime(*time.strptime(a, "%Y/%m/%d")[0:5])
                self.enddate = time.mktime(temp_date.timetuple())
            if o in ('--git-verbose'):
                self.opt_gitverbose = True
            if o in ('-h', '--help'):
                self.usage(['intro', 'stats', 'filtering', 'common'])
                sys.exit()
            if o in ('-v', '--verbose'):
                self.opt_verbose = True
            self.apply_filtering(o, a)

        self.verify_filtering()

        if self.enddate <= self.startdate:
          temp_date = self.enddate
          self.enddate = self.startdate
          self.startdate = temp_date

        self.parse_gnome_release_data()

        # We add more repositories. You can specify single modules, or groups of modules from a release.
        release = self.gnome_release_data['release']
        language = self.gnome_release_data['language']
        print 'Release      :', self.highlight(self.release), '     retrieved release:', self.gnome_release_data['release']
        print 'Language     :', self.highlight(self.language), '             retrieved language:', self.gnome_release_data['language']
        print 'Repositories :', self.highlight(self.dir_vcs)
        print 'Start date   :', self.highlight(datetime.fromtimestamp(self.startdate).ctime())
        print 'End date     :', self.highlight(datetime.fromtimestamp(self.enddate).ctime())
        print
        for cat in list(self.gnome_release_data['categories'].keys()):
            if self.category != '' and cat != self.category:
                continue
            if self.opt_verbose:
                print '    Category: %(cat)s' % { 'cat': self.highlighttitle(cat) }
            for mod in self.gnome_release_data['categories'][cat]:
                if self.module != '' and mod != self.module:
                    continue
                if self.opt_verbose:
                    print '        Module: %(br)35s, Branch: %(mod)s' % { 'br': self.highlightitem(mod), \
                        'mod': self.highlightitem2(self.gnome_release_data['categories'][cat][mod]['branch']) }
                for resource in self.gnome_release_data['categories'][cat][mod]['resource']:
                    if self.transtype:
                        if resource['id'] not in self.transtype:
                            continue
                    if self.opt_verbose:
                        print '        ID:', resource['id'], 'Type:', resource['type']
                        print '          VCSPath:', resource['vcspath']
                    repository = mod
                    location = re.split('\/browse\/', resource['vcspath'])[1]
                    subdir = re.split('\/', location, maxsplit=1)[1]
                    vcspath = re.sub('^http', 'git', resource['vcspath'])
                    vcspath = re.sub('\/browse\/', '/git/', vcspath)
                    branch = self.gnome_release_data['categories'][cat][mod]['branch']
                    resourceid = resource['id']
                    repositorypath = self.dir_vcs + repository
                    if resourceid == 'domain':
                        pofile = self.dir_vcs + repository + '/' + subdir + '/' + self.language + '.po'
                    elif resourceid == 'document':
                        pofile = self.dir_vcs + repository + '/' + subdir + '/' + self.language + '/' + self.language + '.po'
                    else:
                      print "Invalid resource id", resourceid
                      sys.exit(-20)
                    
                    if os.path.exists(repositorypath):
                        print 'Analysing for', pofile
                        self.analyse_contributions(repositorypath, pofile, branch)
                        print


    def analyse_contributions(self, repositorypath, pofile, branch):
        if not os.path.exists(pofile):
            return

        args_checkout_master = ['/usr/bin/git', 'checkout', 'master']
        args_checkout_branch = ['/usr/bin/git', 'checkout', '--track', 'origin/' + branch]
        args_checkout_stats  = ['/usr/bin/git', 'checkout', '-b', 'l10n-stats']
        args_delete_stats    = ['/usr/bin/git', 'branch', '-D', 'l10n-stats']
        args_delete_branch   = ['/usr/bin/git', 'branch', '-D', branch]
        args_remove_commit   = ['/usr/bin/git', 'reset', '--quiet', '--hard', 'HEAD^1']
        args_reset_hard   = ['/usr/bin/git', 'reset', '--quiet', '--hard']

        subprocess.call(args_checkout_master, cwd = repositorypath)
        subprocess.call(args_checkout_branch, cwd = repositorypath)
        subprocess.call(args_checkout_stats, cwd = repositorypath)
       
        repo = git.Repo(repositorypath)
        commits = repo.iter_commits('l10n-stats', max_count=10000)
        previouspofile = '/tmp/gnome-l10n-translator-stats-latest-' + branch + str(random.random())
        shutil.copyfile(pofile, previouspofile)

        firsttime = True
        emptytranslation = False

        for i in commits:
            if firsttime:
              firsttime = False

              previous_author = i.author
              previous_authored_date = i.authored_date
              previous_committer = i.committer
              previous_committed_date = i.committed_date
              previous_message = i.message
              previous_hash = self.file_md5(pofile)
              previous_size = os.path.getsize(pofile)

            if emptytranslation:
              break

            # If commit is within our range,
            if i.authored_date >= self.startdate and i.authored_date <= self.enddate:
                try:
                    # If translation file exists,
                    if os.path.exists(pofile):
                        # If current file has changed,
                        if previous_hash != self.file_md5(pofile):
                            #print "[1]", self.highlightitem(previous_author.name), self.highlight(previous_message), previous_hash, self.file_md5(pofile)
                            #print "[1]", self.highlightitem(i.author.name), self.highlight(i.message), previous_hash, self.file_md5(pofile)
                            print "[1]", self.highlightitem(x_author)

                        # Keep copy of current file
                        shutil.copyfile(pofile, previouspofile)

                        # Calculate the hash of the current file
                        previous_hash = self.file_md5(pofile)
                        previous_size = os.path.getsize(pofile)

                        x_author = previous_author.name
                        previous_author = i.author
                        previous_authored_date = i.authored_date
                        previous_committer = i.committer
                        previous_committed_date = i.committed_date
                        previous_message = i.message

                        aa = previous_author.name[0:6]
                        if aa == "Simos" or aa == "Kostas" or aa == "Nikos " or aa == "Sterio":
                            print "XXX", previous_author.name

                        # Pop up the last commit
                        #repo.index.reset(commit='HEAD^1')
                        subprocess.call(args_remove_commit, cwd = repositorypath)
                    else:
                      emptytranslation = True
                      print "FINAL:", self.highlightitem(previous_author.name), self.highlight(previous_message)
                      print "[FINAL]", self.highlightitem(x_author)
                      next
                except OSError, err:
                  pass

        os.unlink(previouspofile)
        subprocess.call(args_checkout_master, cwd = repositorypath)
        subprocess.call(args_delete_stats, cwd = repositorypath)
        subprocess.call(args_delete_branch, cwd = repositorypath)

    def get_po_file_data(self, pofile):
        if not self.gnome_release_data:
            self.parse_gnome_release_data()

        for cat in list(self.gnome_release_data['categories'].keys()):
            if self.category != '' and cat != self.category:
                continue
            for mod in self.gnome_release_data['categories'][cat]:
                if self.module != '' and mod != self.module:
                    continue
                for resource in self.gnome_release_data['categories'][cat][mod]['resource']:
                    if pofile == resource['pofile'].rsplit('/')[-1]:
                        return resource['vcspath']
        return None

    def is_empty(self):
        for dir in [self.dir_po]:
            dircontents = dircache.listdir(dir)
            dircontents = dircontents[:]
            if dircontents:
                return False
        return True

    def perform_on_repositories(self, command, description, append_name = False, append_nameslashstar = False):
        dircontents = dircache.listdir(self.dir_vcs)
        dircontents = dircontents[:]
        if dircontents:
            count = 1
            total = len(dircontents)
            for item in dircontents:
                if self.getkey.kbhit():
                    print self.highlight('A key was pressed; interrupting the process')
                    return
                if self.module != '' and item != self.module:
                    continue
                if os.path.isdir(self.dir_vcs + item):
                    if type(command).__name__ == 'function':
                        if self.opt_verbose:
                            indexnums = self.highlight('%(aa)3d/%(total)d' % { 'aa': count, 'total': total })
                            print '%(index)s -- Running function on %(dir)s' % \
                                { 'index': indexnums, 'dir': self.highlightitem(self.dir_vcs + item) }
                        if not self.opt_dryrun:
                            command(self.dir_vcs + item)
                        else:
                            print '\tcmd(' + self.dir_vcs + item + ')'
                    elif type(command).__name__ == 'str':
                        CMD = 'cd ' + self.dir_vcs + item + '; ' + command
                        if append_name:
                            CMD = CMD + item
                        elif append_nameslashstar:
                            CMD = CMD + item + '/*'
                        if self.opt_verbose:
                            print '%(aa)3d/%(total)d -- Running command %(cmd)s' % \
                                { 'aa': count, 'total': total, 'cmd': CMD }
                        if not self.opt_dryrun:
                            indexnums = self.highlight('%(aa)3d/%(total)d' % { 'aa': count, 'total': total })
                            print '%(index)s -- %(desc)s %(dir)s' % \
                                { 'index': indexnums, 'desc': self.highlighttitle(description), 'dir': self.highlightitem(self.dir_vcs + item) }
                            os.system(CMD)
                        else:
                            print '\t', self.highlighttitle(description), self.highlightitem(self.dir_vcs + item)
                            print '\t', CMD
                    else:
                        print 'Error, unknown type', type(command)
                        sys.exit(-1)
                count += 1

    def init(self):
        if self.opt_dryrun:
            self.process_stats('print')
        else:
            self.process_stats('execute')

    def parse_gnome_release_data(self):
        filename = 'managevcs-%s-%s.xml' % (self.language, self.release)
        filepath = os.path.join(os.curdir, filename)
        xmlurl = 'http://l10n.gnome.org/languages/' + self.language + '/' + self.release + '/xml'
        if self.opt_verbose: 
          print "Retrieving for language", self.language, "and release", self.release
          print "for URL", xmlurl
          print "and saving as", filename
        ### WE ARE CACHING WHILE TESTING. UNCOMMENT BELOW BEFORE RELEASE
        #self.download_file(xmlurl, filepath)

        # An error page is about 2.5KB, a proper XML file is circa 50KB.
        if os.path.getsize(filepath) < 5000:
            print 'Language', self.language, 'was not found.\nExiting...'
            print xmlurl
            os.remove(filepath)
            sys.exit(-7)

        if self.opt_verbose:
            print 'Retrieved GNOME release data for', self.release, xmlurl

        self.gnome_release_data = self.parse_gnome_xml_file(filepath)

        if self.opt_verbose:
            print "Done parsing gnome release data"

    def parse_gnome_xml_file(self, filename):
        try:
            xmlfile = open(filename, 'r')
            xmlfile.close
        except OSError:
            print 'Could not open file ', filename, '. Aborting...'
            sys.exit(-1)

        contents = ''.join(xmlfile.readlines())

        mytarget = GNOMEI18nTarget.GNOMEI18nTarget()
        parser = etree.XMLParser(target = mytarget)
        result = etree.XML(contents, parser)

        return mytarget.get_stats()

    def usage(self, helpIDs):
        # Help text message
        help_intro = self.highlight('gnome-l10n-translator-stats') + ', ' + self.highlightitem('a tool that produces statistics for GNOME translation work') + \
        """\nUsage: gnome-l10n-translator-stats <action> <options>\n"""

        help_stats = self.highlight('stats') + self.highlighttitle('      Produce translation stats') + """
\t\t--language LANG     specify the language code per ISO 639
\t\t--startdate DATE    specify the start date (such as '2010/01/31')
\t\t--enddate DATE      specify the end date (such as '2010/06/30')
\t\t--release REL       specify GNOME release (such as 'gnome-2-26')
\t\t--repositories DIR  specify the directory with the GNOME VCS repositories
"""

        help_cleanup = self.highlight('cleanup') + self.highlighttitle('      Cleanup repositories of stat branches') + """
\t\t--release REL       specify GNOME release (such as 'gnome-2-26')
\t\t--repositories DIR  specify the directory with the GNOME VCS repositories
"""

        help_filtering = self.highlighttitle('Module filtering (optional)') + """
\t-c CAT  --category CAT      i18n category name CAT (such as 'desktop')
\t-m MODU --module MOD        i18n module name MOD (such as 'gnome-games')
\t-t TYPE --transtype TYPE    optionally specify translation type, either ui or doc
"""

        help_common = self.highlighttitle('Common options') + """
\t-d      --dry-run           do not really perform the action
\t-h      --help              this craft
\t-v      --verbose           show verbose output
"""

        help_help = """Invoke with --help for full help options."""

        help_messages = {
            'intro': help_intro,
            'stats': help_stats,
            'cleanup': help_cleanup,
            'filtering': help_filtering,
            'common': help_common,
            'help': help_help
        }

        for id in helpIDs:
            print help_messages[id]

    def download_hook(self, blocks_transferred, block_size, file_size):
        """ A download hook to provide some feedback when downloading """
        if blocks_transferred == 0:
            if file_size > 0:
                if self.opt_verbose:
                    sys.stdout.write('Downloading ' + str(file_size) + ' bytes: ')
                else:
                    if self.opt_verbose:
                        sys.stdout.write('Downloading: ')
        if self.opt_verbose:
            sys.stdout.write('#')
            sys.stdout.flush()


    def download_file(self, url, filepath):
        """
        Downloads a file provided a URL and saves it as filepath.
        """

        if self.opt_verbose:
            sys.stdout.write('Downloading ' + url + ' ')
        # Download the file, regardless if it exists or not.
        try:
            urllib.urlretrieve(url, filepath, self.download_hook)
        except IOError as data_ioerror:
            (errno, strerror) = data_ioerror.args
            if self.opt_verbose:
                print
            print 'While trying to download', url
            print 'I/O error(%s): %s' % (errno, strerror)
            sys.exit(-1)
        except OSError as err:
            print 'Unexpected error: ', err
            sys.exit(-1)

        if self.opt_verbose:
            print ' done.'

    def apply_filtering(self, o, a):
        if o in ('-c', '--category'):
            self.category = a
        if o in ('-m', '--module'):
            self.module = a
        if o in ('--transtype'):
            if a in ['ui', 'domain']:
                self.transtype = 'domain'
            elif a in ['doc', 'document']:
                self.transtype = 'document'
            else:
                print 'ERROR: Invalid transtype, expected on of ui, doc, domain, document'
                sys.exit(-4)

    def verify_filtering(self):
        if self.category == '' or self.module == '' or self.transtype == '':
          if self.opt_verbose:
            if self.category:
                print "Filtering on category:", self.category
            if self.module:
                print "Filtering on module:", self.module
            if self.transtype:
                print "Filtering on translation type: ", self.transtype

    def file_md5(self, filename, block_size=128):
      f = open(str(filename), 'r')
      md5 = hashlib.md5()
      while True:
        data = f.read(block_size)
        if not data:
           break
        md5.update(data)
      return md5.hexdigest()

if __name__ == '__main__':
    start = GNOMEL10nTranslatorStats(sys.argv)
