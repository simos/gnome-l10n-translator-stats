#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>

# Author  : Simos Xenitellis <simos@gnome.org>, 2009
# Version : 0.9

import dircache                 # dircache.listdir()
import os                       # os.system(), os.remove(), os.path.gmtime(), os.getenv()
import getopt                   # getopt.getopt()
import shutil                   # shutil.rmtree()
import sys                      # sys.argv, sys.exit()
import urllib                   # urllib.urlretrieve()
import ConfigParser             # ConfigParser()
import TextColorPrint
import GetKey                   # for GetKey.getch()
from datetime import datetime   # datetime()

from xdg.BaseDirectory import * # XDG Python support, ...

import GNOMEI18nTarget

try:
    from lxml import etree      # etree.XMLParser(), etree.XML()
except ImportError as err:
    print 'Import error:', err
    print 'This script requires to have the "python-lxml" package installed'
    print 'Please install the package python-lxml and try again.\nExiting...'
    sys.exit(-10)

PROGNAME='gnome-i18n-manage-vcs'

PACKAGE_NAME    = 'GNOME L10n Translator Stats'
PACKAGE_VERSION = '0.1'
PACKAGE_AUTHORS = ['Simos Xenitellis <simos@gnome.org>']
PACKAGE_COPYRIGHT = 'Copyright 2010 Simos Xenitellis'

class GNOMEL10nTranslatorStats:
    # Required configuration options
    language = ''

    # Options used for filtering
    all = False
    category = ''
    module = ''
    release = ''
    transtype = ''              # either 'doc' or 'ui' (for 'document' or 'domain' in XML)

    common_short = 'dhv'
    common_long = ['dry-run', 'help', 'verbose']

    filter_short = 'c:m:r:t:'
    filter_long = ['all', 'category=', 'module=', 'release=', 'transtype=']

    gnome_release_data = []

    dir_vcs = ''
    file_START = 'START'

    file_CONFIG = ''

    # Text color object
    tc = ''

    action_config = False
    action_stats = False

    opt_commit = False
    opt_clone = False
    opt_dryrun = False
    opt_eponymous = False
    opt_init = False
    opt_cleanall = False
    opt_gitverbose = False
    opt_gitquiet = False
    opt_nocheckout = False
    opt_trim = False
    opt_verbose = False
    opt_vcsreset = False
    opt_vcsupdate = False

    def __init__(self, argv):
        # Initialise the text color object
        self.tc = TextColorPrint.TextColorPrint()

        # getkey object for kbhit()
        self.getkey = GetKey.GetKey()

        # If no args, show basic help.
        if not argv[1:]:
            self.usage(['intro', 'help'])
            sys.exit(0)

        # Establish where the configuration file should be stored as per the
        # XDG directories recommendation by the Freedesktop organization.
        self.conf_dir = os.path.join(xdg_config_home, PROGNAME)
        # Create the directory if it doesn't exist
        if not os.path.isdir(self.conf_dir):
            os.mkdir(self.conf_dir)

        self.data_dir = os.path.join(xdg_data_home, PROGNAME)
        # Create the directory if it doesn't exist
        if not os.path.isdir(self.data_dir):
            os.mkdir(self.data_dir)

        # Set the configuration filename and path.
        self.conf_file = os.path.join(self.conf_dir, '%s.conf' % PROGNAME)

        # Identify the action selected.
        if argv[1] == 'config':
                self.action_config = True
        elif argv[1] == 'stats':
                self.action_stats = True
        else:
            self.usage(['intro', 'stats',
                        'filtering', 'common'])
            sys.exit(0)

        # Perform the 'config' action.
        if self.action_config:
            self.process_config(argv[2:])
            sys.exit(0)

        # Read the configuration file.
        self.readconfig()

        # Perform the subsequence actions.
        if self.action_stats:
            self.process_stats(argv[2:])

        # Execution ends.
        print 'Action has just completed.'
        sys.exit(0)

    def highlight(self, str):
        ''' Returns a string with ANSI codes that print as color on the terminal window. '''
        return self.tc.cprint(str, 'red')

    def highlightitem(self, str):
        ''' Returns a string with ANSI codes that print as color on the terminal window. '''
        return self.tc.cprint(str, 'green')

    def highlighttitle(self, str):
        ''' Returns a string with ANSI codes that print as color on the terminal window. '''
        return self.tc.cprint(str, 'blue')

    def process_config(self, cmdargs):
        ''' Process the 'config' action. '''
        # If no arguments, show 'config' specific help.
        if not cmdargs:
            self.usage(['intro', 'config'])
            sys.exit(0)

        # Build command line argument filter.
        try:
            this_filter = [ 'language=' ];
            this_filter.extend(self.common_long)
            opts, args = getopt.getopt(cmdargs, 'l' + self.common_short, this_filter)
        except getopt.GetoptError as err:
            print 'Error: %s' % str(err)
            self.usage(['intro' ])
            sys.exit(0)

        # Retrieve parament values.
        listconfig = False
        for o, a in opts:
            if o in ('-h', '--help'):
                self.usage(['intro', 'stats',
                            'filtering', 'common'])
                sys.exit()
            if o in ('--language'):
                self.language = a
            if o in ('-l'):
                listconfig = True

        # Perform '-l' (list) option.
        if not os.path.exists(self.conf_dir):
            print 'Could not find a configuration file: %s' % self.conf_dir
            print 'Creating new configuration file...'
        elif listconfig:
            self.readconfig()
            print 'Configuration file (%s)' % self.highlight(self.conf_dir)
            print
            print 'Language code      =', self.highlight(self.language)
            sys.exit(0)

        # Print diagnostics that one of the tuple is not defined.
        if self.language == '':
            print 'Error: Required parameter(s) missing for configuration'
            print 'When using the "config" action for the first time, please specify all of the'
            print 'following.'
            print ' 1. --language LANG, language (ISO 639), i.e. en_GB, el, fr, es'
            print
            print 'Received: language =', self.language
            print
            print 'Use --help for  more help.'
            print 'Exiting...'
            sys.exit(-1)

        # Make sure we have directories for po and vcs files.
        self.createreleasedirectory(self.release)

        # Show diagnostics for created directories.
        for dir in [self.dir_vcs]:
            if not os.path.exists(dir):
                print 'Directory', dir, 'does not exist.'
                print 'Please create it and try again.'
                print 'Exiting...'
                sys.exit(-1)

    def process_stats(self, cmdargs):
        self.show_stats(cmdargs)

    def process_vcsmanage(self, cmdargs):
        self.dir_vcs = self.get_release_config(self.release)
        if not cmdargs:
            self.usage(['intro', 'vcsmanage', 'filtering', 'common'])
            sys.exit(0)

        try:
                this_filter_short = self.common_short + self.filter_short
                this_filter_long = ['cleanall',
                'commit', 'clone', 'eponymous',
                'no-checkout',
                'reset', 'git-quiet', 'git-verbose', 'trim',
                'update-vcs', 'updatevcs',
                'vcsupdate', 'vcs-update'];
                this_filter_long.extend(self.common_long)
                this_filter_long.extend(self.filter_long)
                opts, args = getopt.getopt(cmdargs, this_filter_short, this_filter_long)
        except getopt.GetoptError as err:
            print 'Error', err
            self.usage(['intro', 'vcsmanage', 'filtering', 'common'])
            sys.exit(0)
        for o, a in opts:
            if o in ('--cleanall'):
                self.opt_cleanall = True
            if o in ('--clone'):
                self.opt_clone = True
            if o in ('--dryrun', '--dry-run'):
                self.opt_dryrun = True
            if o in ('--eponymous'):
                self.opt_eponymous = True
            if o in ('--git-quiet'):
                self.opt_gitquiet = True
            if o in ('--git-verbose'):
                self.opt_gitverbose = True
            if o in ('-h', '--help'):
                self.usage(['intro', 'vcsmanage', 'filtering', 'common'])
                sys.exit()
            if o in ('--no-checkout'):
                self.opt_nocheckout = True
            if o in ('--reset'):
                self.opt_vcsreset = True
            if o in ('--trim'):
                self.opt_trim = True
            if o in ('-v', '--verbose'):
                self.opt_verbose = True
            if o in ('--update-vcs', '--updatevcs', '--vcs-update', '--vcsupdate'):
                self.opt_vcsupdate = True
            self.apply_filtering(o, a)

        self.verify_filtering()

        if self.opt_vcsreset:
            # Perform hard reset on repositories
            self.perform_on_repositories('git reset --hard origin/master', 'Performing hard reset on')
        elif self.opt_cleanall:
            # Remove all repositories
            self.perform_on_repositories(shutil.rmtree, 'Removing repositories')
        elif self.opt_eponymous:
            # Convert clones to eponymous ones. Sets the username to self.username.
            cmd_remote_url_partial = 'git config remote.origin.url ssh://' + self.username+ '@git.gnome.org/git/'
            self.perform_on_repositories(cmd_remote_url_partial, 'Converting repository to eponymous', append_name = True)
        elif self.opt_trim:
            # Erase the working copy of each repository.
            cmd_erase_working_copy = 'rm -fr ' + self.dir_vcs
            self.perform_on_repositories(cmd_erase_working_copy, 'Erasing working copy for', append_nameslashstar = True)
        elif self.opt_vcsupdate:
            # Perform 'git pull --rebase' for each repository.
            cmd_pull = 'git pull --rebase'
            self.perform_on_repositories(cmd_pull, 'Performing a git pull --rebase in')

        if self.opt_clone:
            # We add more repositories. You can specify single modules, or groups of modules from a release.
            if self.module:
                self.clone_module(self.module, self.username)
            elif self.release:
                print "Cloning release", self.highlight(self.release), "category:", self.highlightitem(self.category)
                self.parse_gnome_release_data()
            else:
                print "You need to specify a release"
            release = self.gnome_release_data['release']
            language = self.gnome_release_data['language']
            self.dir_po, self.dir_vcs = self.get_release_config(self.release)
            print 'Language :', self.language
            print 'Directories:', self.dir_po, self.dir_vcs
            for cat in list(self.gnome_release_data['categories'].keys()):
                if self.category != '' and cat != self.category:
                    continue
                print '    Category: %(cat)s' % { 'cat': cat }
                for mod in self.gnome_release_data['categories'][cat]:
                    if self.module != '' and mod != self.module:
                        continue
                    print '        Module: %(br)22s, Branch: %(mod)s' % { 'br': mod, \
                        'mod': self.gnome_release_data['categories'][cat][mod]['branch'] }
                    for resource in self.gnome_release_data['categories'][cat][mod]['resource']:
                        if self.transtype:
                            if resource['id'] not in self.transtype:
                                continue
                        if self.opt_verbose:
                            print '        ID:', resource['id'], 'Type:', resource['type']
                            print '          POFile:', resource['pofile']
                            print '          VCSPath:', resource['vcspath']
                        if self.username == 'anonymous':
                            vcspath = 'git://git.gnome.org/' + mod
                        else:
                            vcspath = 'ssh://' + self.username + '@' + 'git.gnome.org/git/' + mod
                        branch = self.gnome_release_data['categories'][cat][mod]['branch']

                        CMD1 = 'cd ' + self.dir_vcs + ';'
                        if self.opt_gitquiet:
                            if self.opt_nocheckout:
                                CMD1 = CMD1 + 'git clone --no-checkout --quiet ' + vcspath
                            else:
                                CMD1 = CMD1 + 'git clone --quiet ' + vcspath
                        else:
                            if self.opt_nocheckout:
                                CMD1 = CMD1 + 'git clone --no-checkout ' + vcspath
                            else:
                                CMD1 = CMD1 + 'git clone ' + vcspath

                        if self.opt_dryrun and self.opt_verbose:
                            print '            CMD:', CMD1
                        elif not self.opt_dryrun:
                            if os.path.exists(self.dir_vcs + mod):
                                #print 'Cached repository for', mod, 'exists. Skipping cloning...'
                                pass
                            else:
                                print 'Retrieving module', mod, '...'
                                if self.opt_verbose:
                                    print
                                    sys.stdout.flush()
                                os.system(CMD1)
                                if not self.opt_verbose:
                                    sys.stdout.write(' ' * 80 + '\r')
                                    sys.stdout.flush()
            if not self.opt_verbose:
                print ' ' * 80
                pass

    def get_po_file_data(self, pofile):
        if not self.gnome_release_data:
            self.parse_gnome_release_data()

        if self.gnome_release_data['release'] != self.release:
            print 'Mismatched release data', self.release, self.gnome_release_data['release']
        if self.gnome_release_data['language'] != self.language:
            print 'Mismatched language data', self.language, self.gnome_release_data['language']
        for cat in list(self.gnome_release_data['categories'].keys()):
            if self.category != '' and cat != self.category:
                continue
            for mod in self.gnome_release_data['categories'][cat]:
                if self.module != '' and mod != self.module:
                    continue
                for resource in self.gnome_release_data['categories'][cat][mod]['resource']:
                    if pofile == resource['pofile'].rsplit('/')[-1]:
                        return resource['vcspath']
        return None

    def is_empty(self):
        for dir in [self.dir_po]:
            dircontents = dircache.listdir(dir)
            dircontents = dircontents[:]
            if dircontents:
                return False
        return True

    def perform_on_repositories(self, command, description, append_name = False, append_nameslashstar = False):
        dircontents = dircache.listdir(self.dir_vcs)
        dircontents = dircontents[:]
        if dircontents:
            count = 1
            total = len(dircontents)
            for item in dircontents:
                if self.getkey.kbhit():
                    print self.highlight('A key was pressed; interrupting the process')
                    return
                if self.module != '' and item != self.module:
                    continue
                if os.path.isdir(self.dir_vcs + item):
                    if type(command).__name__ == 'function':
                        if self.opt_verbose:
                            indexnums = self.highlight('%(aa)3d/%(total)d' % { 'aa': count, 'total': total })
                            print '%(index)s -- Running function on %(dir)s' % \
                                { 'index': indexnums, 'dir': self.highlightitem(self.dir_vcs + item) }
                        if not self.opt_dryrun:
                            command(self.dir_vcs + item)
                        else:
                            print '\tcmd(' + self.dir_vcs + item + ')'
                    elif type(command).__name__ == 'str':
                        CMD = 'cd ' + self.dir_vcs + item + '; ' + command
                        if append_name:
                            CMD = CMD + item
                        elif append_nameslashstar:
                            CMD = CMD + item + '/*'
                        if self.opt_verbose:
                            print '%(aa)3d/%(total)d -- Running command %(cmd)s' % \
                                { 'aa': count, 'total': total, 'cmd': CMD }
                        if not self.opt_dryrun:
                            indexnums = self.highlight('%(aa)3d/%(total)d' % { 'aa': count, 'total': total })
                            print '%(index)s -- %(desc)s %(dir)s' % \
                                { 'index': indexnums, 'desc': self.highlighttitle(description), 'dir': self.highlightitem(self.dir_vcs + item) }
                            os.system(CMD)
                        else:
                            print '\t', self.highlighttitle(description), self.highlightitem(self.dir_vcs + item)
                            print '\t', CMD
                    else:
                        print 'Error, unknown type', type(command)
                        sys.exit(-1)
                count += 1

    def init(self):
        if self.opt_dryrun:
            self.process_stats('print')
        else:
            self.process_stats('execute')

    def parse_gnome_release_data(self):
        filename = 'managevcs-%s-%s.xml' % (self.language, self.release)
        filepath = os.path.join(os.curdir, filename)
        xmlurl = 'http://l10n.gnome.org/languages/' + self.language + '/' + self.release + '/xml'
        self.download_file(xmlurl, filepath)

        # An error page is about 2.5KB, a proper XML file is circa 50KB.
        if os.path.getsize(filepath) < 5000:
            print 'Language', self.language, 'was not found.\nExiting...'
            print xmlurl
            os.remove(filepath)
            sys.exit(-7)

	if (self.opt_verbose):
		print 'Retrieved GNOME release data for', self.release, xmlurl
        self.gnome_release_data = self.parse_gnome_xml_file(filepath)

    def parse_gnome_xml_file(self, filename):
        try:
            xmlfile = open(filename, 'r')
            xmlfile.close
        except OSError:
            print 'Could not open file ', filename, '. Aborting...'
            sys.exit(-1)

        contents = ''.join(xmlfile.readlines())

        mytarget = GNOMEI18nTarget.GNOMEI18nTarget()
        parser = etree.XMLParser(target = mytarget)
        result = etree.XML(contents, parser)

        return mytarget.get_stats()

    def usage(self, helpIDs):
        # Help text message
        help_intro = self.highlight('gnome-l10n-translator-stats') + ', ' + self.highlightitem('a tool that produces statistics for GNOME translation work') + \
        """\nUsage: gnome-l10n-translator-stats <action> <options>\n"""

        help_stats = self.highlight('stats') + self.highlighttitle('      Produce translation stats') + """
\t\t--language LANG     specify the language code per ISO 639
\t\t--startdate DATE    specify the start date
\t\t--enddate DATE      specify the end date
\t\t--release REL       specify GNOME release (such as 'gnome-2-26')
\t\t--repositories DIR  specify the directory with the GNOME VCS repositories
"""

        help_filtering = self.highlighttitle('Module filtering  (applies to vcsmanage, poget, commit)') + """
\t        --all               apply action to all locally available repositories
\t-c CAT  --category CAT      i18n category name CAT (such as 'desktop')
\t-m MODU --module MOD        i18n module name MOD (such as 'gnome-games')
\t-t TYPE --transtype TYPE    optionally specify translation type, either ui or doc
"""

        help_common = self.highlighttitle('Common options') + """
\t-d      --dry-run           do not really perform the action
\t-h      --help              this craft
\t-v      --verbose           show verbose output
"""

        help_help = """Invoke with --help for full help options."""

        help_messages = {
            'intro': help_intro,
            'stats': help_stats,
            'filtering': help_filtering,
            'common': help_common,
            'help': help_help
        }

        for id in helpIDs:
            print help_messages[id]

    def download_hook(self, blocks_transferred, block_size, file_size):
        """ A download hook to provide some feedback when downloading """
        if blocks_transferred == 0:
            if file_size > 0:
                if self.opt_verbose:
                    sys.stdout.write('Downloading ' + str(file_size) + ' bytes: ')
                else:
                    if self.opt_verbose:
                        sys.stdout.write('Downloading: ')
        if self.opt_verbose:
            sys.stdout.write('#')
            sys.stdout.flush()


    def download_file(self, url, filepath):
        """
        Downloads a file provided a URL and saves it as filepath.
        """

        if self.opt_verbose:
            sys.stdout.write('Downloading ' + url + ' ')
        # Download the file, regardless if it exists or not.
        try:
            urllib.urlretrieve(url, filepath, self.download_hook)
        except IOError as data_ioerror:
            (errno, strerror) = data_ioerror.args
            if self.opt_verbose:
                print
            print 'While trying to download', url
            print 'I/O error(%s): %s' % (errno, strerror)
            sys.exit(-1)
        except OSError as err:
            print 'Unexpected error: ', err
            sys.exit(-1)

        if self.opt_verbose:
            print ' done.'

    def writeconfig(self):
        config = ConfigParser.ConfigParser()

        try:
            config.add_section('GNOME-I18n-Manage-VCS')
            if self.language:
                config.set('GNOME-I18n-Manage-VCS', 'language', self.language)
            #self.dir_vcs = os.path.join(self.data_dir, self.release, 'vcs/')
            #config.set('GNOME-I18n-Manage-VCS', 'vcsdir', self.dir_vcs)
            #self.dir_po = os.path.join(self.data_dir, self.release, 'po/')
            #config.set('GNOME-I18n-Manage-VCS', 'podir', self.dir_po)
        except ConfigParser.NoOptionError as err:
            print 'Error:', err
            sys.exit(10)

        try:
            cf = open(self.conf_file, 'wb')
            config.write(cf)
            cf.close()
        except Exception as e:
            print 'Oooops'

    def readconfig(self):
        """
        Reads the existing configuration file.
        """
        config = ConfigParser.ConfigParser()

        if os.path.exists(self.conf_file):
            config.read(self.conf_file)

            try:
                self.language = config.get('GNOME-I18n-Manage-VCS', 'language')
                #self.dir_po = os.path.join(self.data_dir, self.release, 'po/')
                #self.dir_vcs = os.path.join(self.data_dir, self.release, 'vcs/')
            except ConfigParser.NoOptionError as err:
                if not self.action_config:
                    print 'Error:', str(err)
                    print 'Please use --config and the relevant argument to set the missing setting'
                    print 'Exiting...'
                    sys.exit(10)
        #else:
        #    print "The configuration file %s was not found." % self.conf_file
        #    print "It is required to perform the initial configuration, before issuing commands."
        #    sys.exit(10)

    def get_release_config(self, release):
        dir_po = os.path.join(self.data_dir, 'po/')
        dir_vcs = os.path.join(self.data_dir, 'vcs/')

        return dir_po, dir_vcs

    def apply_filtering(self, o, a):
        if o in ('--all'):
            self.all = True
        if o in ('-c', '--category'):
            self.category = a
        if o in ('-m', '--module'):
            self.module = a
        if o in ('-r', '--release'):
            self.release = a
        if o in ('--transtype'):
            if a in ['ui', 'domain']:
                self.transtype = 'domain'
            elif a in ['doc', 'document']:
                self.transtype = 'document'
            else:
                print 'ERROR: Invalid transtype, expected on of ui, doc, domain, document'
                sys.exit(-4)

    def verify_filtering(self):
        if self.all == False and self.category == '' and self.module == '' and self.release == '' and self.transtype == '':
            if not self.opt_cleanall:
                print 'Error: It is required to specify at least one of release, category, module or translation type, or specify all.'
                sys.exit(8)

if __name__ == '__main__':
    start = GNOMEL10nTranslatorStats(sys.argv)
